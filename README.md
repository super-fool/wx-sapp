WebView 就是一个内置的浏览器，微信中能打开网页就是因为其内置了一个 WebView 容器。

WeiXin JS 接口封装了**原生接口**作为**微信原生接口**提供给我们进行调用。WeiXinJSBridge API 就属于其中的一个接口。

2015 年，微信发布了一整套网页开发工具：JS-SDK.(SDK = software development kit)

JS-SDK 是对 WeiXinJSBridge API 的一个包装或者说是他的超集。

微信为解决受屏加载过长(即白屏时间),从而在 JS-SDK 中新增了一个功能：**微信 Web 资源离线存储**。
这个功能只针对公众号中的文章，将这些文章中的静态资源存储在微信本地，每个公众号最多可缓存 5M.
但是对于 CSS，JS 加载过多的页面时，还是会有白屏问题，而且还会存在页面切换生硬和点击延迟等。

为了提供更快的加载速度，更强大的能力，更高效的开发，便产生了**小程序**。

> 小程序与网页的区别:

1. 小程序的渲染层和逻辑层是分开的，逻辑层是运行在 JSCore 中的，无法去调用 DOM/BOM API 及 JQ 和 VUE 等包含 DOM 的框架库。
2. 小程序所在意的兼容性只有 IOS 和 Android.

| 运行环境 | 逻辑层 | 渲染层         |
| -------- | ------ | -------------- |
| IOS      | JSCore | WKWebView      |
| Android  | V8     | Chromium       |
| 开发工具 | NWJS   | chrome webview |

# 小程序

## 架构

### JSON 配置

JSON 是一种数据格式，我们通常用来表示**静态配置**

`app.json`：全局配置清单，包括页面路径，通用样式，[参考配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

### app.json

> pages: 页面路径
> 是一个数组, 第一项作为首页.

- window: 全局默认配置

- plugins: 声明需要的插件,需要在**设置-第三方服务-插件管理**进行配置;可以配合 subpackages 进行分包加载插件; functionalPages:来声明开发功能页.

- preloadRule: 进行分包预下载.

- navigateToMiniProgramAppIdList: 跳转至其他小程序.

- usingComponents: 声明全局自定义组件.

- permission: 接口权限相关设置.

### project.config.json

个性化配置清单
[参考配置](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)

### WXML 模板

是一个被封装了多个微信标签(组件)的*HTML 模板*, 例如:`view,button`; 在这些标签中也封装了微信的标签属性,例如:`wx:if`

> 目的就是:**让开发人员只关注状态管理和业务逻辑**,实现`OOP/COP`模式,而不是`POP`模式.

## WXSS 模板

样式属性与`CSS`一致, 只不过新增了`rpx`尺寸单位. 减少了适配性的问题.

## 框架

<<<<<<< HEAD

### WXSS 模板

样式属性与`CSS`一致, 只不过新增了`rpx`尺寸单位. 减少了适配性的问题.

## 宿主环境

[文档地址](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html#%E6%B8%B2%E6%9F%93%E5%B1%82%E5%92%8C%E9%80%BB%E8%BE%91%E5%B1%82)
宿主环境包含:

1. 渲染层(App Service): WXML, WXSS
2. 逻辑层(View): JS
3. 微信客户端(Native):
   - 逻辑层和渲染层交互的介质,即 MVVM 中的 VM 层.
   - 逻辑层中接口请求至后端的中间层,即请求必须先通过 Native 再请求第三方服务器.

### 逻辑层

#### 全局函数：app.js

小程序进入后，第一步会调用`app.js`全局脚本。在里面只有一个`App(options)`函数,里面注入了以下几个监听函数及一个全局对象：

```js
globalData: {}, // 全局数据
onLaunch(){},// init
onShow(){}, // inited & show
onHide(){}, // hide
onPageNotFound(){}, // not found
userInfoReadyCallback(){}, // 这个
onUnlaunch(){}, // destory
```

所有函数的 this 都是指向该`App(options)`这个参数。

通过`getApp()`获取全局实例。

#### 页面函数：page.js

## 组件

### block

不会渲染的一个包裹元素，**非组件，只接受控制属性**。

## 性能优化

### 列表展示页

小程序在渲染 1000 个 DOM 节点以上的页面时， 经常会造成内存不足而出现闪退的问题。

优化点：

1. 可以通过判断某个组件是否达到渲染临界点再开始渲染，超出屏幕的组件可以使用`WX:IF`来卸载组件。

参考：https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html

# 性能

dom 节点过多，图片节点过多

小程序内存占用 500M 会出现卡顿

小程序建议的总节点数不能超过**1000**

# 多人点餐

## 引导按钮

### 业务分析

1. 有三种状态：**全部展示 ｜ 展示一个 ｜ 全部隐藏**：
   - 全部展示入口：第一次进去 / 点击半隐藏
   - 展示一个入口：第一次进去的 5s 后 / 停止滑动的 2s 后
   - 全部隐藏口入：滑动时

### 技术分析

1. 对于引导按钮组件是属于绝对定位：`position: fixed`
2. 因为对于隐藏，展示引导组件可以使用`right:0 / -item-width`，由于 setDate 会引发性能问题，所以这三种最好是在前端使用 if/else 来判断三种类型的组件分别展示。
3. 由于使用 onscroll, 我们可以用节流/防抖限制触发时间的频率。
4. 需要优化的背景最好不要使用透明。

### 组件抽象

1. 由于按钮刷量会根据条件来展示不同，并且没有太多的交互逻辑，所以可以抽取成一个展示组件。

## 多人邀请

### 业务分析

1. 此业务入口从引导按钮的多人点餐按钮进入。
2. 进入该页面会有个人的点餐码进行展示，输入时有三种情况：
   - 输入自己的点餐码时，进入自己的菜单
   - 输入别人的点餐码时进入，进入朋友的菜单
   - 输入的点餐码如果不存在，则提示弹窗

### 技术分析

1. 需要创建一个虚拟键盘，即 前端文本框 输入数字的功能
2. 针对按键进行一个监听，当输入第四个值时进入 业务的三种情况判断

### 组件抽象

1. 由于不是弹出键盘，所以需要将虚拟键盘进行一个组件封装

## 点餐列表

### 业务分析

1. 菜品分为： 会员/非会员； 有规格/无规格； 他人点餐/ 自己点餐
2. 点击菜品进入菜品详情页，点击规格进入规格选择页

Q?

1. 多人操作的提示： 持续几秒？
2. 桌位码不一致，点餐码一致？
3. 提示他人已提交订单，那自己去结算是属于更新订单吗？
4. 提交逻辑有出入
5. 用菜的数量颜色来展示是否是他人点餐合适用户体验？
6. 确定菜品是有规格的吗？

### 技术分析

1. 图片大小分析：是否与商家协商定长宽进行展示，还是默认选择裁剪模式进行展示
2. 菜系需要进行一个高度监听，每一个菜系高度 \* 菜系数量，如果值大于页面高度，当点击中间的菜系或菜品下滑至中间菜系时，菜系列表高度进行自增
3. 数量限制：是否能从数据库取出该菜的剩余数量，或者前端默认一个最大数量。 如果超过最大数量进行提示。
4. 添加图片禁止/启用选择的图标。
5. 算好每一个菜品高度，做到初始页面菜品都是完整展示。
6. 每一个 request 都请求两个/三个菜系的菜品，每当上拉到第二个/第三个菜系的菜品时，再次请求下面菜系的菜品进行 concat
7. 菜品名称是否换行展示
8. 图片懒加载

#### 列表解决思路：

1. 按菜系分页式请求数据。（提高后端查询效率）
2. Item（即菜品）在非视口区域进行卸载，视口区进行加载。（解决 DOM 节点冗余）
3. 由于Item卸载后无法进行监听，需要使用一个view（骨架）来填充Item高度
3. 给每个 Item 添加一个骨架，用来填充高度。（防止回流）
4. 交叉监听高度设为屏高的2倍，防止一些Item高度较高（如特大图版菜品）， 容易溢出视口会导致setData频繁触发。

#### 父子列表列表分析：

1. 点击父item，子item滚动至视口顶部。
2. 滚动左侧不影响右侧，滚动右侧时会联动左侧高亮显示。
3. 


列表优化：
将超出屏幕的组件节点用`wx:if`来进行卸载。
假设屏幕最多显示 5 个 item，每次根据菜系请求的 item 进行划分为：前，中，后 item。
当 前 item 滑出屏幕，可以使用一个骨架记录其高度进行填充，并将其骨架放置一个数组中进行记录，然后卸载 前 item。
如果来回滑动时，可以去骨架数组中去判断是否记录高度，不再重复记录。**这样可以防止回流，只需要重绘**。



### 组件抽象

1. 菜系组件：就是一个展示 list 组件
2. 菜品组件：是一个容器 list 组件，包含：
   - 会员/非会员： 抽象
   - 规格/无规格：抽象
   - 图片

## 购物车

### 业务分析

1. 可以添加菜品缩略图
2. 多人点餐时，如果有人是会员，有人不是，那么购物车应该怎么结算
3. 商品数量与总价展示不对

### 技术分析

1. 购物车数据可通过点餐页获取数据：eventChannel

### 组件分析

1. 个人组件：通过 userinfo 获取，如果无授权就展示默认
2. 菜品详情组件
3.
